//src/main/java/br/com/tourapp/config/SecurityConfig.java
package br.com.tourapp.config;

import br.com.tourapp.security.JwtAuthenticationFilter;
import br.com.tourapp.security.CustomUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(CustomUserDetailsService userDetailsService,
                         JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.userDetailsService = userDetailsService;
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                // Endpoints públicos
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/webhook/**").permitAll()
                .requestMatchers("/health", "/actuator/health").permitAll()
                .requestMatchers("/actuator/**").permitAll()

                // Endpoints de organizador
                .requestMatchers("/organizador/**").hasRole("ORGANIZADOR")

                // Endpoints de cliente
                .requestMatchers("/cliente/**").hasRole("CLIENTE")

                // Endpoints administrativos (futuro)
                .requestMatchers("/admin/**").hasRole("ADMIN")

                // Todos os outros endpoints requerem autenticação
                .anyRequest().authenticated()
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

//src/main/java/br/com/tourapp/config/CorsConfig.java
package br.com.tourapp.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
public class CorsConfig {

    @Value("${app.cors.allowed-origins}")
    private String allowedOriginsStr;

    @Value("${app.cors.allowed-methods}")
    private String allowedMethodsStr;

    @Value("${app.cors.allowed-headers}")
    private String allowedHeaders;

    @Value("${app.cors.allow-credentials}")
    private boolean allowCredentials;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        List<String> allowedOrigins = Arrays.asList(allowedOriginsStr.split(","));
        List<String> allowedMethods = Arrays.asList(allowedMethodsStr.split(","));

        configuration.setAllowedOriginPatterns(allowedOrigins);
        configuration.setAllowedMethods(allowedMethods);
        configuration.setAllowedHeaders(Arrays.asList(allowedHeaders.split(",")));
        configuration.setAllowCredentials(allowCredentials);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);

        return source;
    }
}

//src/main/java/br/com/tourapp/config/CloudinaryConfig.java
package br.com.tourapp.config;

import com.cloudinary.Cloudinary;
import com.cloudinary.utils.ObjectUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CloudinaryConfig {

    @Value("${app.cloudinary.cloud-name}")
    private String cloudName;

    @Value("${app.cloudinary.api-key}")
    private String apiKey;

    @Value("${app.cloudinary.api-secret}")
    private String apiSecret;

    @Value("${app.cloudinary.secure}")
    private boolean secure;

    @Bean
    public Cloudinary cloudinary() {
        return new Cloudinary(ObjectUtils.asMap(
            "cloud_name", cloudName,
            "api_key", apiKey,
            "api_secret", apiSecret,
            "secure", secure
        ));
    }
}

//src/main/java/br/com/tourapp/config/MercadoPagoConfig.java
package br.com.tourapp.config;

import com.mercadopago.MercadoPagoConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

import jakarta.annotation.PostConstruct;

@Configuration
public class MercadoPagoConfiguration {

    @Value("${app.mercadopago.access-token}")
    private String accessToken;

    @PostConstruct
    public void init() {
        MercadoPagoConfig.setAccessToken(accessToken);
    }
}

//src/main/java/br/com/tourapp/config/FirebaseConfig.java
package br.com.tourapp.config;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;

import jakarta.annotation.PostConstruct;
import java.io.IOException;

@Configuration
public class FirebaseConfig {

    @Value("${app.firebase.service-account-path}")
    private Resource serviceAccountResource;

    @PostConstruct
    public void initialize() {
        try {
            if (FirebaseApp.getApps().isEmpty()) {
                GoogleCredentials credentials = GoogleCredentials
                    .fromStream(serviceAccountResource.getInputStream());

                FirebaseOptions options = FirebaseOptions.builder()
                    .setCredentials(credentials)
                    .build();

                FirebaseApp.initializeApp(options);
            }
        } catch (IOException e) {
            System.err.println("Erro ao inicializar Firebase: " + e.getMessage());
        }
    }
}

//src/main/java/br/com/tourapp/config/AsyncConfig.java
package br.com.tourapp.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // Com JDK 21 e Virtual Threads, podemos ser mais generosos
        executor.setCorePoolSize(50);
        executor.setMaxPoolSize(200);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("TourApp-Async-");
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(30);

        executor.initialize();
        return executor;
    }
}

//src/main/java/br/com/tourapp/config/CacheConfig.java
package br.com.tourapp.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableCaching
public class CacheConfig {

    @Value("${app.cache.enabled}")
    private boolean cacheEnabled;

    @Bean
    public CacheManager cacheManager() {
        if (!cacheEnabled) {
            return new ConcurrentMapCacheManager(); // Cache desabilitado
        }

        return new ConcurrentMapCacheManager(
            "excursoes",
            "organizadores",
            "clientes",
            "dashboard"
        );
    }
}

//src/main/java/br/com/tourapp/config/JacksonConfig.java
package br.com.tourapp.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class JacksonConfig {

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();

        // Modules para melhor suporte
        mapper.registerModule(new JavaTimeModule());
        mapper.registerModule(new Jdk8Module());

        // Configurações de serialização
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);

        return mapper;
    }
}

//src/main/java/br/com/tourapp/config/ModelMapperConfig.java
package br.com.tourapp.config;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ModelMapperConfig {

    @Bean
    public ModelMapper modelMapper() {
        ModelMapper mapper = new ModelMapper();

        // Configuração para mapeamento mais estrito
        mapper.getConfiguration()
            .setMatchingStrategy(MatchingStrategies.STRICT)
            .setFieldMatchingEnabled(true)
            .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE);

        return mapper;
    }
}

//src/main/java/br/com/tourapp/config/ValidationConfig.java
package br.com.tourapp.config;

import jakarta.validation.Validator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

@Configuration
public class ValidationConfig {

    @Bean
    public Validator validator() {
        return new LocalValidatorFactoryBean();
    }

    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        MethodValidationPostProcessor processor = new MethodValidationPostProcessor();
        processor.setValidator(validator());
        return processor;
    }
}

//src/main/java/br/com/tourapp/controller/AuthController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.CadastroClienteRequest;
import br.com.tourapp.dto.request.CadastroOrganizadorRequest;
import br.com.tourapp.dto.request.LoginRequest;
import br.com.tourapp.dto.response.AuthResponse;
import br.com.tourapp.service.AuthService;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
@CrossOrigin(origins = "*")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@Valid @RequestBody LoginRequest request) {
        AuthResponse response = authService.login(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/cadastro/cliente")
    public ResponseEntity<AuthResponse> cadastroCliente(@Valid @RequestBody CadastroClienteRequest request) {
        AuthResponse response = authService.cadastrarCliente(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/cadastro/organizador")
    public ResponseEntity<AuthResponse> cadastroOrganizador(@Valid @RequestBody CadastroOrganizadorRequest request) {
        AuthResponse response = authService.cadastrarOrganizador(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthResponse> refresh(@RequestHeader("Authorization") String token) {
        AuthResponse response = authService.refreshToken(token);
        return ResponseEntity.ok(response);
    }
}

//src/main/java/br/com/tourapp/controller/PublicController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.InscricaoRequest;
import br.com.tourapp.dto.response.ExcursaoResponse;
import br.com.tourapp.dto.response.InscricaoResponse;
import br.com.tourapp.service.ExcursaoService;
import br.com.tourapp.service.InscricaoService;
import br.com.tourapp.dto.SecurityUser;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/public")
@CrossOrigin(origins = "*")
public class PublicController {

    private final ExcursaoService excursaoService;
    private final InscricaoService inscricaoService;

    public PublicController(ExcursaoService excursaoService, InscricaoService inscricaoService) {
        this.excursaoService = excursaoService;
        this.inscricaoService = inscricaoService;
    }

    @GetMapping("/excursoes/{id}")
    public ResponseEntity<ExcursaoResponse> obterExcursaoPublica(@PathVariable UUID id) {
        ExcursaoResponse response = excursaoService.obterExcursaoPublica(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/excursoes/{excursaoId}/inscricoes")
    public ResponseEntity<InscricaoResponse> inscreverNaExcursao(
            @PathVariable UUID excursaoId,
            @Valid @RequestBody InscricaoRequest request,
            @AuthenticationPrincipal SecurityUser user) {
        InscricaoResponse response = inscricaoService.criarInscricao(excursaoId, request, user.getId());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/health")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("OK");
    }
}

//src/main/java/br/com/tourapp/controller/ClienteController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.response.ClienteResponse;
import br.com.tourapp.dto.response.InscricaoResponse;
import br.com.tourapp.service.ClienteService;
import br.com.tourapp.service.InscricaoService;
import br.com.tourapp.dto.SecurityUser;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/cliente")
@PreAuthorize("hasRole('CLIENTE')")
public class ClienteController {

    private final ClienteService clienteService;
    private final InscricaoService inscricaoService;

    public ClienteController(ClienteService clienteService, InscricaoService inscricaoService) {
        this.clienteService = clienteService;
        this.inscricaoService = inscricaoService;
    }

    @GetMapping("/perfil")
    public ResponseEntity<ClienteResponse> obterPerfil(@AuthenticationPrincipal SecurityUser user) {
        ClienteResponse response = clienteService.obterPerfil(user.getId());
        return ResponseEntity.ok(response);
    }

    @PutMapping("/perfil")
    public ResponseEntity<ClienteResponse> atualizarPerfil(
            @RequestBody ClienteResponse request,
            @AuthenticationPrincipal SecurityUser user) {
        ClienteResponse response = clienteService.atualizarPerfil(user.getId(), request);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/inscricoes")
    public ResponseEntity<Page<InscricaoResponse>> listarInscricoes(
            @AuthenticationPrincipal SecurityUser user,
            Pageable pageable) {
        Page<InscricaoResponse> response = inscricaoService.listarInscricoesPorCliente(user.getId(), pageable);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/inscricoes/{id}")
    public ResponseEntity<InscricaoResponse> obterInscricao(
            @PathVariable UUID id,
            @AuthenticationPrincipal SecurityUser user) {
        InscricaoResponse response = inscricaoService.obterInscricaoPorCliente(id, user.getId());
        return ResponseEntity.ok(response);
    }

    @PutMapping("/notificacoes/push-token")
    public ResponseEntity<Void> atualizarPushToken(
            @RequestParam String pushToken,
            @AuthenticationPrincipal SecurityUser user) {
        clienteService.atualizarPushToken(user.getId(), pushToken);
        return ResponseEntity.ok().build();
    }

    @PutMapping("/notificacoes/configuracoes")
    public ResponseEntity<Void> atualizarConfiguracoes(
            @RequestParam Boolean emailNotifications,
            @RequestParam Boolean smsNotifications,
            @AuthenticationPrincipal SecurityUser user) {
        clienteService.atualizarConfiguracoes(user.getId(), emailNotifications, smsNotifications);
        return ResponseEntity.ok().build();
    }
}

//src/main/java/br/com/tourapp/controller/OrganizadorController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.response.DashboardResponse;
import br.com.tourapp.dto.response.InscricaoResponse;
import br.com.tourapp.dto.response.OrganizadorResponse;
import br.com.tourapp.service.OrganizadorService;
import br.com.tourapp.service.InscricaoService;
import br.com.tourapp.dto.SecurityUser;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.UUID;

@RestController
@RequestMapping("/organizador")
@PreAuthorize("hasRole('ORGANIZADOR')")
public class OrganizadorController {

    private final OrganizadorService organizadorService;
    private final InscricaoService inscricaoService;

    public OrganizadorController(OrganizadorService organizadorService, InscricaoService inscricaoService) {
        this.organizadorService = organizadorService;
        this.inscricaoService = inscricaoService;
    }

    @GetMapping("/perfil")
    public ResponseEntity<OrganizadorResponse> obterPerfil(@AuthenticationPrincipal SecurityUser user) {
        OrganizadorResponse response = organizadorService.obterPerfil(user.getId());
        return ResponseEntity.ok(response);
    }

    @PutMapping("/perfil")
    public ResponseEntity<OrganizadorResponse> atualizarPerfil(
            @RequestBody OrganizadorResponse request,
            @AuthenticationPrincipal SecurityUser user) {
        OrganizadorResponse response = organizadorService.atualizarPerfil(user.getId(), request);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/dashboard")
    public ResponseEntity<DashboardResponse> obterDashboard(
            @AuthenticationPrincipal SecurityUser user,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim) {
        DashboardResponse response = organizadorService.obterDashboard(user.getId(), dataInicio, dataFim);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/inscricoes")
    public ResponseEntity<Page<InscricaoResponse>> listarTodasInscricoes(
            @AuthenticationPrincipal SecurityUser user,
            @RequestParam(required = false) UUID excursaoId,
            Pageable pageable) {
        Page<InscricaoResponse> response = inscricaoService.listarInscricoesPorOrganizador(
                user.getId(), excursaoId, pageable);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/excursoes/{excursaoId}/inscricoes")
    public ResponseEntity<Page<InscricaoResponse>> listarInscricoesPorExcursao(
            @PathVariable UUID excursaoId,
            @AuthenticationPrincipal SecurityUser user,
            Pageable pageable) {
        Page<InscricaoResponse> response = inscricaoService.listarInscricoesPorExcursao(
                excursaoId, user.getId(), pageable);
        return ResponseEntity.ok(response);
    }
}

//src/main/java/br/com/tourapp/controller/ExcursaoController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.ExcursaoRequest;
import br.com.tourapp.dto.response.ExcursaoResponse;
import br.com.tourapp.enums.StatusExcursao;
import br.com.tourapp.service.ExcursaoService;
import br.com.tourapp.dto.SecurityUser;
import jakarta.validation.Valid;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/organizador/excursoes")
@PreAuthorize("hasRole('ORGANIZADOR')")
public class ExcursaoController {

    private final ExcursaoService excursaoService;

    public ExcursaoController(ExcursaoService excursaoService) {
        this.excursaoService = excursaoService;
    }

    @PostMapping
    public ResponseEntity<ExcursaoResponse> criarExcursao(
            @Valid @ModelAttribute ExcursaoRequest request,
            @AuthenticationPrincipal SecurityUser user) {
        ExcursaoResponse response = excursaoService.criarExcursao(request, user.getId());
        return ResponseEntity.ok(response);
    }

    @GetMapping
    public ResponseEntity<Page<ExcursaoResponse>> listarExcursoes(
            @AuthenticationPrincipal SecurityUser user,
            @RequestParam(required = false) StatusExcursao status,
            Pageable pageable) {
        Page<ExcursaoResponse> response = excursaoService.listarExcursoesPorOrganizador(
                user.getId(), status, pageable);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ExcursaoResponse> obterExcursao(
            @PathVariable UUID id,
            @AuthenticationPrincipal SecurityUser user) {
        ExcursaoResponse response = excursaoService.obterExcursaoPorOrganizador(id, user.getId());
        return ResponseEntity.ok(response);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ExcursaoResponse> atualizarExcursao(
            @PathVariable UUID id,
            @Valid @ModelAttribute ExcursaoRequest request,
            @AuthenticationPrincipal SecurityUser user) {
        ExcursaoResponse response = excursaoService.atualizarExcursao(id, request, user.getId());
        return ResponseEntity.ok(response);
    }

    @PatchMapping("/{id}/status")
    public ResponseEntity<ExcursaoResponse> alterarStatus(
            @PathVariable UUID id,
            @RequestParam StatusExcursao status,
            @AuthenticationPrincipal SecurityUser user) {
        ExcursaoResponse response = excursaoService.alterarStatusExcursao(id, status, user.getId());
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> excluirExcursao(
            @PathVariable UUID id,
            @AuthenticationPrincipal SecurityUser user) {
        excursaoService.excluirExcursao(id, user.getId());
        return ResponseEntity.noContent().build();
    }
}

//src/main/java/br/com/tourapp/controller/PagamentoController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.PagamentoCartaoRequest;
import br.com.tourapp.dto.request.PagamentoPixRequest;
import br.com.tourapp.dto.response.PagamentoResponse;
import br.com.tourapp.service.PagamentoService;
import br.com.tourapp.dto.SecurityUser;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/pagamentos")
@PreAuthorize("hasRole('CLIENTE')")
public class PagamentoController {

    private final PagamentoService pagamentoService;

    public PagamentoController(PagamentoService pagamentoService) {
        this.pagamentoService = pagamentoService;
    }

    @PostMapping("/pix")
    public ResponseEntity<PagamentoResponse> criarPagamentoPix(
            @Valid @RequestBody PagamentoPixRequest request,
            @AuthenticationPrincipal SecurityUser user) {
        PagamentoResponse response = pagamentoService.criarPagamentoPix(request, user.getId());
        return ResponseEntity.ok(response);
    }

    @PostMapping("/cartao")
    public ResponseEntity<PagamentoResponse> criarPagamentoCartao(
            @Valid @RequestBody PagamentoCartaoRequest request,
            @AuthenticationPrincipal SecurityUser user) {
        PagamentoResponse response = pagamentoService.criarPagamentoCartao(request, user.getId());
        return ResponseEntity.ok(response);
    }
}

//src/main/java/br/com/tourapp/controller/NotificacaoController.java
package br.com.tourapp.controller;

import br.com.tourapp.dto.request.NotificacaoRequest;
import br.com.tourapp.dto.response.NotificacaoResponse;
import br.com.tourapp.entity.Cliente;
import br.com.tourapp.service.NotificacaoService;
import br.com.tourapp.dto.SecurityUser;
import jakarta.validation.Valid;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/organizador/notificacoes")
@PreAuthorize("hasRole('ORGANIZADOR')")
public class NotificacaoController {

    private final NotificacaoService notificacaoService;

    public NotificacaoController(NotificacaoService notificacaoService) {
        this.notificacaoService = notificacaoService;
    }

    @PostMapping
    public ResponseEntity<NotificacaoResponse> criarNotificacao(
            @Valid @RequestBody NotificacaoRequest request,
            @AuthenticationPrincipal SecurityUser user) {
        NotificacaoResponse response = notificacaoService.criarNotificacao(request, user.getId());
        return ResponseEntity.ok(response);
    }

    @PostMapping("/{id}/enviar")
    public ResponseEntity<Void> enviarNotificacao(
            @PathVariable UUID id,
            @AuthenticationPrincipal SecurityUser user) {
        notificacaoService.enviarNotificacao(id, user.getId());
        return ResponseEntity.ok().build();
    }

    @GetMapping
    public ResponseEntity<Page<NotificacaoResponse>> listarNotificacoes(
            @AuthenticationPrincipal SecurityUser user,
            Pageable pageable) {
        Page<NotificacaoResponse> response = notificacaoService.listarNotificacoesPorOrganizador(user.getId(), pageable);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/clientes/{excursaoId}")
    public ResponseEntity<List<Cliente>> listarClientesPorExcursao(
            @PathVariable UUID excursaoId,
            @AuthenticationPrincipal SecurityUser user) {
        List<Cliente> response = notificacaoService.listarClientesPorExcursao(excursaoId, user.getId());
        return ResponseEntity.ok(response);
    }
}

//src/main/java/br/com/tourapp/controller/WebhookController.java
package br.com.tourapp.controller;

import br.com.tourapp.service.PagamentoService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/webhook")
@CrossOrigin(origins = "*")
public class WebhookController {

    private final PagamentoService pagamentoService;

    public WebhookController(PagamentoService pagamentoService) {
        this.pagamentoService = pagamentoService;
    }

    @PostMapping("/mercadopago")
    public ResponseEntity<String> webhookMercadoPago(@RequestBody Map<String, Object> payload) {
        try {
            // Verificar se é um evento de pagamento
            if ("payment".equals(payload.get("type"))) {
                Map<String, Object> data = (Map<String, Object>) payload.get("data");
                String paymentId = (String) data.get("id");

                pagamentoService.processarWebhookMercadoPago(paymentId);
            }

            return ResponseEntity.ok("OK");
        } catch (Exception e) {
            System.err.println("Erro ao processar webhook: " + e.getMessage());
            return ResponseEntity.ok("OK"); // Sempre retornar OK para o MP
        }
    }
}

//src/main/java/br/com/tourapp/security/JwtUtil.java
package br.com.tourapp.security;

import br.com.tourapp.enums.TipoUsuario;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${app.jwt.secret}")
    private String secret;

    @Value("${app.jwt.expiration}")
    private int jwtExpiration;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public String extractUserId(String token) {
        return extractClaim(token, claims -> claims.get("userId", String.class));
    }

    public TipoUsuario extractTipoUsuario(String token) {
        String tipo = extractClaim(token, claims -> claims.get("tipoUsuario", String.class));
        return TipoUsuario.valueOf(tipo);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(UserDetails userDetails, UUID userId, TipoUsuario tipoUsuario) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId.toString());
        claims.put("tipoUsuario", tipoUsuario.name());
        return createToken(claims, userDetails.getUsername());
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + jwtExpiration))
                .signWith(getSigningKey())
                .compact();
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    public Boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(getSigningKey())
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}

//src/main/java/br/com/tourapp/security/SecurityUser.java
package br.com.tourapp.security;

import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.enums.TipoUsuario;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.UUID;

public class SecurityUser implements UserDetails {

    private final UUID id;
    private final String email;
    private final String senha;
    private final String nome;
    private final TipoUsuario tipoUsuario;
    private final boolean ativo;

    public SecurityUser(Cliente cliente) {
        this.id = cliente.getId();
        this.email = cliente.getEmail();
        this.senha = cliente.getSenha();
        this.nome = cliente.getNome();
        this.tipoUsuario = cliente.getTipoUsuario();
        this.ativo = cliente.getAtivo();
    }

    public SecurityUser(Organizador organizador) {
        this.id = organizador.getId();
        this.email = organizador.getEmail();
        this.senha = organizador.getSenha();
        this.nome = organizador.getNomeEmpresa();
        this.tipoUsuario = organizador.getTipoUsuario();
        this.ativo = organizador.getStatus().name().equals("ATIVO");
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        String role = "ROLE_" + tipoUsuario.name();
        return Collections.singletonList(new SimpleGrantedAuthority(role));
    }

    @Override
    public String getPassword() {
        return senha;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return ativo;
    }

    // Getters adicionais
    public UUID getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    public String getNome() {
        return nome;
    }

    public TipoUsuario getTipoUsuario() {
        return tipoUsuario;
    }
}

//src/main/java/br/com/tourapp/security/CustomUserDetailsService.java
package br.com.tourapp.security;

import br.com.tourapp.entity.Cliente;
import br.com.tourapp.entity.Organizador;
import br.com.tourapp.repository.ClienteRepository;
import br.com.tourapp.repository.OrganizadorRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final ClienteRepository clienteRepository;
    private final OrganizadorRepository organizadorRepository;

    public CustomUserDetailsService(ClienteRepository clienteRepository,
                                  OrganizadorRepository organizadorRepository) {
        this.clienteRepository = clienteRepository;
        this.organizadorRepository = organizadorRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        // Tentar encontrar como cliente primeiro
        Optional<Cliente> cliente = clienteRepository.findByEmail(email);
        if (cliente.isPresent()) {
            return new SecurityUser(cliente.get());
        }

        // Se não encontrou como cliente, tentar como organizador
        Optional<Organizador> organizador = organizadorRepository.findByEmail(email);
        if (organizador.isPresent()) {
            return new SecurityUser(organizador.get());
        }

        throw new UsernameNotFoundException("Usuário não encontrado com email: " + email);
    }
}

//src/main/java/br/com/tourapp/security/JwtAuthenticationFilter.java
package br.com.tourapp.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);

    private final JwtUtil jwtUtil;
    private final CustomUserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, CustomUserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {

        String authorizationHeader = request.getHeader("Authorization");

        String email = null;
        String jwt = null;

        // Extrair token do cabeçalho Authorization
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            try {
                email = jwtUtil.extractUsername(jwt);
            } catch (Exception e) {
                logger.warn("Token JWT inválido: {}", e.getMessage());
            }
        }

        // Se temos email e não há autenticação no contexto
        if (email != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            try {
                UserDetails userDetails = userDetailsService.loadUserByUsername(email);

                // Validar token
                if (jwtUtil.validateToken(jwt, userDetails)) {
                    UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());

                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                }
            } catch (Exception e) {
                logger.warn("Erro ao autenticar usuário: {}", e.getMessage());
            }
        }

        filterChain.doFilter(request, response);
    }
}

